
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Duck Adventure - Python Powered</title>
    <style>
        /* Estilização da interface e do canvas */
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: sans-serif; }
        canvas { display: block; background: linear-gradient(#87CEEB, #228B22); }
        
        #hud {
            position: absolute; top: 20px; left: 20px;
            color: white; font-size: 24px; font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3); padding: 15px; border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="hud">Frutas: <span id="score">0</span></div>
    <canvas id="gameCanvas"></canvas>

<script>
/**
 * CLASSE VETOR 
 * Auxilia nos cálculos matemáticos de posição e movimento
 */
class Vetor {
    constructor(x, y) { this.x = x; this.y = y; }
}

/**
 * CLASSE FRUTA
 * Representa os coletáveis. Cada tipo tem uma cor e pontuação.
 */
class Fruta {
    constructor(x, y, tipo) {
        this.pos = new Vetor(x, y);
        this.tipo = tipo;
        this.raio = 12;
        this.coletada = false;
        this.timer = 0; // Para animação de flutuação
    }

    desenhar(ctx, camX) {
        if (this.coletada) return;
        this.timer += 0.1;
        let flutuar = Math.sin(this.timer) * 5; // Movimento senoidal vertical

        ctx.save();
        ctx.translate(this.pos.x - camX, this.pos.y + flutuar);
        
        // Cor baseada no tipo
        ctx.fillStyle = this.tipo === 'maca' ? '#ff3333' : '#ffcc00';
        ctx.beginPath();
        ctx.arc(0, 0, this.raio, 0, Math.PI * 2);
        ctx.fill();
        
        // Cabinho da fruta
        ctx.fillStyle = '#4a2c2a';
        ctx.fillRect(-2, -18, 4, 8);
        ctx.restore();
    }
}

/**
 * CLASSE PLATAFORMA
 * Blocos sólidos do cenário
 */
class Plataforma {
    constructor(x, y, w, h) {
        this.x = x; this.y = y;
        this.w = w; this.h = h;
    }

    desenhar(ctx, camX) {
        ctx.fillStyle = '#4e342e'; // Terra
        ctx.fillRect(this.x - camX, this.y, this.w, this.h);
        ctx.fillStyle = '#2e7d32'; // Grama (topo)
        ctx.fillRect(this.x - camX, this.y, this.w, 10);
    }
}

/**
 * CLASSE PLAYER (O PATO)
 * Contém física, animação e lógica de controle
 */
class Pato {
    constructor() {
        this.pos = new Vetor(100, 300);
        this.vel = new Vetor(0, 0);
        this.largura = 40;
        this.altura = 40;
        this.noChao = false;
        this.pulosDisponiveis = 2; // Pulo duplo
        this.lado = 1; // 1 para direita, -1 para esquerda
        this.anim = 0; // Contador para animação da capa
    }

    atualizar(controles, plataformas) {
        // --- Movimentação Horizontal ---
        if (controles.esquerda) {
            this.vel.x = -6;
            this.lado = -1;
        } else if (controles.direita) {
            this.vel.x = 6;
            this.lado = 1;
        } else {
            this.vel.x *= 0.8; // Atrito
        }

        // --- Gravidade ---
        this.vel.y += 0.8;
        this.pos.x += this.vel.x;

        // --- Colisão Horizontal ---
        for (let p of plataformas) {
            if (this.pos.x < p.x + p.w && this.pos.x + this.largura > p.x &&
                this.pos.y < p.y + p.h && this.pos.y + this.altura > p.y) {
                if (this.vel.x > 0) this.pos.x = p.x - this.largura;
                if (this.vel.x < 0) this.pos.x = p.x + p.w;
            }
        }

        this.pos.y += this.vel.y;
        this.noChao = false;

        // --- Colisão Vertical ---
        for (let p of plataformas) {
            if (this.pos.x < p.x + p.w && this.pos.x + this.largura > p.x &&
                this.pos.y < p.y + p.h && this.pos.y + this.altura > p.y) {
                if (this.vel.y > 0) { // Caindo
                    this.pos.y = p.y - this.altura;
                    this.vel.y = 0;
                    this.noChao = true;
                    this.pulosDisponiveis = 2; // Reset pulo duplo
                } else if (this.vel.y < 0) { // Batendo cabeça
                    this.pos.y = p.y + p.h;
                    this.vel.y = 0;
                }
            }
        }

        // Animação da capa
        this.anim += 0.15;
    }

    pular() {
        if (this.pulosDisponiveis > 0) {
            this.vel.y = -15;
            this.pulosDisponiveis--;
            this.noChao = false;
        }
    }

    desenhar(ctx, camX) {
        let x = this.pos.x - camX;
        let y = this.pos.y;

        // Desenhar Capa (com balanço)
        ctx.fillStyle = '#C62828';
        let balanco = Math.sin(this.anim) * 5;
        ctx.beginPath();
        if (this.lado === 1) {
            ctx.moveTo(x + 5, y + 10);
            ctx.lineTo(x - 15 - (this.vel.x), y + 35 + balanco);
            ctx.lineTo(x + 10, y + 30);
        } else {
            ctx.moveTo(x + 35, y + 10);
            ctx.lineTo(x + 55 - (this.vel.x), y + 35 + balanco);
            ctx.lineTo(x + 30, y + 30);
        }
        ctx.fill();

        // Desenhar Corpo do Pato
        ctx.fillStyle = '#FFEB3B';
        ctx.fillRect(x, y, this.largura, this.altura);
        
        // Bico
        ctx.fillStyle = '#FF9800';
        if (this.lado === 1) ctx.fillRect(x + 30, y + 15, 15, 10);
        else ctx.fillRect(x - 5, y + 15, 15, 10);
        
        // Olho
        ctx.fillStyle = 'black';
        let olhoX = (this.lado === 1) ? x + 25 : x + 10;
        ctx.beginPath();
        ctx.arc(olhoX, y + 12, 3, 0, Math.PI * 2);
        ctx.fill();
    }
}

/**
 * MOTOR PRINCIPAL DO JOGO
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const player = new Pato();
const plataformas = [
    new Plataforma(0, 500, 1000, 200),
    new Plataforma(1200, 400, 800, 300),
    new Plataforma(400, 300, 200, 30),
    new Plataforma(700, 200, 200, 30),
    new Plataforma(1400, 200, 300, 30)
];
const frutas = [
    new Fruta(500, 250, 'maca'),
    new Fruta(800, 150, 'banana'),
    new Fruta(1500, 150, 'maca'),
    new Fruta(1300, 350, 'banana')
];

let camX = 0;
let score = 0;
const controles = { esquerda: false, direita: false };

// Escuta de teclado
window.addEventListener('keydown', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') controles.esquerda = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') controles.direita = true;
    if (e.code === 'Space') player.pular();
});

window.addEventListener('keyup', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') controles.esquerda = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') controles.direita = false;
});

// Loop de jogo
function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Atualizar jogador
    player.atualizar(controles, plataformas);
    
    // Atualizar Câmera (seguindo o jogador)
    let alvoCam = player.pos.x - canvas.width / 2;
    camX += (alvoCam - camX) * 0.1;

    // Desenhar cenário e objetos
    plataformas.forEach(p => p.desenhar(ctx, camX));
    frutas.forEach(f => {
        f.desenhar(ctx, camX);
        // Detecção de colisão com fruta
        if (!f.coletada && Math.abs(player.pos.x - f.pos.x) < 30 && Math.abs(player.pos.y - f.pos.y) < 30) {
            f.coletada = true;
            score++;
            scoreEl.innerText = score;
        }
    });

    player.desenhar(ctx, camX);
    
    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
